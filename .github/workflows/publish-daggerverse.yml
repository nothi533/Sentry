name: Publish to Daggerverse

on:
  push:
    branches:
      - main
    paths:
      - '.dagger/**'
      - 'dagger.json'
      - '.github/workflows/publish-daggerverse.yml'

jobs:
  # =============================================================================
  # Stage 1: Version - Create semantic version tag based on conventional commits
  # =============================================================================
  version:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to push tags
    outputs:
      new_tag: ${{ steps.create-tag.outputs.new_tag }}
      prev_tag: ${{ steps.create-tag.outputs.prev_tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for tags
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create semantic version tag
        id: create-tag
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Get the latest tag, default to v0.0.0 if no tags exist
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Parse version components (remove 'v' prefix)
          VERSION=${LATEST_TAG#v}
          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)

          # Get commits since last tag
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMITS=$(git log --pretty=format:"%s")
          else
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s")
          fi

          # Determine version bump based on conventional commits
          # For 0.0.x versions, always use patch bumps
          if [ "$MAJOR" = "0" ] && [ "$MINOR" = "0" ]; then
            BUMP_TYPE="patch"
            echo "In 0.0.x range - using patch bump"
          else
            BUMP_TYPE="patch"

            # Check for breaking changes (major bump)
            if echo "$COMMITS" | grep -qiE "^(BREAKING CHANGE|breaking:|.*!:)"; then
              BUMP_TYPE="major"
            # Check for features (minor bump)
            elif echo "$COMMITS" | grep -qiE "^feat(\(.*\))?:"; then
              BUMP_TYPE="minor"
            # Check for fixes and other changes (patch bump)
            elif echo "$COMMITS" | grep -qiE "^(fix|chore|docs|style|refactor|perf|test)(\(.*\))?:"; then
              BUMP_TYPE="patch"
            fi
          fi

          echo "Bump type: $BUMP_TYPE"

          # Calculate new version
          if [ "$BUMP_TYPE" = "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$BUMP_TYPE" = "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "New tag: $NEW_TAG"

          # Create and push tag
          git tag -a $NEW_TAG -m "Release $NEW_TAG"
          git push origin $NEW_TAG

          echo "Created and pushed tag: $NEW_TAG"
          
          # Set outputs for dependent jobs
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "prev_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

  # =============================================================================
  # Stage 2: Release - Create GitHub Release with release notes
  # =============================================================================
  release:
    runs-on: ubuntu-latest
    needs: version
    permissions:
      contents: write  # Required to create releases
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for tags

      - name: Fetch latest tags
        run: git fetch --tags

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
          NEW_TAG: ${{ needs.version.outputs.new_tag }}
          PREV_TAG: ${{ needs.version.outputs.prev_tag }}
        run: |
          TAG=$NEW_TAG

          if [ "$PREV_TAG" = "v0.0.0" ]; then
            # First release - use all commits
            RELEASE_NOTES=$(git log --pretty=format:"- %s (%h)" $TAG)
          else
            # Generate notes from commits between tags
            RELEASE_NOTES=$(git log --pretty=format:"- %s (%h)" ${PREV_TAG}..${TAG})
          fi

          # Create release notes file
          echo "## Changes" > release_notes.md
          echo "" >> release_notes.md
          echo "$RELEASE_NOTES" >> release_notes.md
          echo "" >> release_notes.md
          echo "---" >> release_notes.md
          echo "" >> release_notes.md
          echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${TAG}" >> release_notes.md
          echo "" >> release_notes.md
          echo "**Daggerverse**: https://daggerverse.dev/mod/github.com/${{ github.repository }}@${TAG}" >> release_notes.md

          gh release create $TAG \
            --title "Release $TAG" \
            --notes-file release_notes.md

  # =============================================================================
  # Stage 3: Publish - Verify and publish module to Daggerverse
  # =============================================================================
  publish:
    runs-on: ubuntu-latest
    needs: [version, release]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch latest tags
        run: git fetch --tags

      - name: Install Dagger CLI
        run: |
          curl -fsSL https://dl.dagger.io/dagger/install.sh | sh
          sudo mv bin/dagger /usr/local/bin/
          dagger version

      - name: Verify module structure
        run: |
          dagger functions
        env:
          DAGGER_CLOUD_TOKEN: ${{ secrets.DAGGER_CLOUD_TOKEN }}

      - name: Publish to Daggerverse
        env:
          DAGGER_CLOUD_TOKEN: ${{ secrets.DAGGER_CLOUD_TOKEN }}
          NEW_TAG: ${{ needs.version.outputs.new_tag }}
        run: |
          MODULE_REF="github.com/${{ github.repository }}@${NEW_TAG}"

          echo "Publishing module: ${MODULE_REF}"

          # Trigger automatic Daggerverse indexing by calling the module
          # This is the official way to publish - calling a remote module automatically indexes it
          dagger call -m ${MODULE_REF} --help || true

          echo "Module called successfully - Daggerverse will index it automatically"
          echo "View at: https://daggerverse.dev/mod/github.com/${{ github.repository }}@${NEW_TAG}"
